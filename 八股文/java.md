##  Java基础

### 接口和抽象类的区别

- 相似点：

  1. 接口和抽象类都不能实例化[^1]

  2. 实现接口和继承抽象类的普通的子类都必须实现这些抽象方法
- 不同点：

  1. 接口类不能包含方法，抽象类可以包含普通代码块和普通方法
  2. 抽象类内部可以有任何类型的成员变量，但是接口类只能有 Public static final 类型的变量，并且必须赋值
  3. 抽象类可以有构造方法，接口不行

[^1]:Demo demo = new Demo(); 通常把这条语句的动作称之为创建一个对象，也就是实例化，其实，它包含了四个动作。(1）右边的“new Demo”，是以Demo类为模板，在堆空间里创建一个Demo类对象（也简称为Demo对象）。(2）末尾的()意味着，在对象创建后，立即调用Demo类的构造函数，对刚生成的对象进行初始化。构造函数是肯定有的。如果你没写，Java会给你补上一个默认的构造函数。(3）左边的“Demo demo”创建了一个Demo 类引用变量。所谓Demo类引用，就是以后可以用来指向Demo对象的对象引用。(4）“=”操作符使对象引用指向刚创建的那个Demo对象。

### 重写和重载的区别

- 重载发生在同一个类中，方法名、参数名、返回类型都相同，权限修饰符可以不一样
- 重写发生在子类当中，方法名、参数名、返回类型都相同，权限修饰符要大于父类方法，声明异常要小于父类方法，final和private修饰的方法不可以重写

###  ==和equals的区别

- ==比较的是引用类型，即内存地址；equals比较的是值
- equals是object类的方法，本质和==一样。但有些类重写了equals方法，比如String的equals被重写后比较的就是字符的值；重写equals后也必须重写hashcode()方法

###  异常处理的机制

- 使用try、catch、finally捕获异常，finally中的代码一定会执行，捕获到异常后程序会继续执行
- 使用throws声明该方法可能会抛出的异常，出现异常后程序终止

### HashMapd原理

- HashMap特点是key不能重复，可以为null,线程不安全（在Jdk1.8以后使用的是数组+链表+红黑树）
- 扩容机制：默认容量是16，负载因子为0.75，当元素个数超过 容量×负载因子，HashMap会创建一个新大小为原来两倍的数组，再将原来数组中的数据复制到新数组中。当数组长度达到64并且链表长度大于8时，链表转为红黑树
- HashMap存取原理：
  1. 计算key的hash值，然后进行二次hash，根据二次hash的结果找到对应的索引位置。
  2. 如果这个位置有值，进行equals比较，为true则取代该元素，结果为false就用 高低位平移法 将节点插入链表（JDK8以前使用头插法，但是头插法在并发扩容时可能会造成环形链表或数据丢失，而高低位平移发会发生数据覆盖的情况）

### 想要线程安全的HashMap怎么办？





###  权限修饰符应该怎么使用？

从作用域来看，public能够使用所有的情况。但是大家在工作的时候，又不会真正全部都使用public，那么到底什么情况该用什么修饰符呢？

属性通常使用private封装起来。
方法一般使用public用于被调用。
会被子类继承的方法，通常使用protected。
default用的不多，一般新手会用default，因为还不知道有修饰符这个东西。
再就是作用范围最小原则：





## 常用开发框架系列

###  什么是Spring？

- Spring是个轻量级的框架，通过IOC来达到解耦的目的，通过AOP将业务逻辑和系统服务分离进行内聚性开发，缺点是配置组件比较繁琐。

###  IOC是什么？

- IOC是一种控制反转的思想，将对象的创建和调用（new对象）交给容器进行管理，减少方法之间的依赖，避免后期对代码进行修改时要到回相应的方法来new对象调用其他方法。
  - 创建bean的方法可以使用：@bean、@componte、xml的方式
  - 在创建一个bean之后需要对他的属性进行填充，我们通常会用@Autowire直接填充依赖注入，他是有限按照类型进行匹配的

### AOP是什么？

- AOP是面向切面编程，将与业务不相关的但是许多业务又要被调用的代码抽离出来，本质是在对原有代码不进行改动的情况下去进行功能增强
  - SpringAOP是基于动态代理实现的，一种是jdk动态代理，一种是cglib代理
    - jdk代理是利用反射来实现的，是调用反射包中的proxy类中的newproxyInstance方法来返回代理对象。这个方法有三个参数，一个是用于加载代理类的类加载器，一个是被代理类实现的接口的class数组和一个用于增强方法的InvocaHandler实现类
    - cglib代理是利用asm开源包来实现的，是把被代理类的class文件加载进来，通过修改他的字节码生成子类来处理

### 如何定义一个全局异常处理类？

- 在自定义的全局异常处理类的类上添加@ControllerAdvice注解，然后定义一些用于捕捉不同异常类型的方法，在这些方法上边添加@ExceptionHandle(value=异常类型.class)和@ResponseBody注解，方法参数是HttpServletRequest和异常类型，然后将异常消息进行处理
- 如果需要自定义异常类的活，就写一个自定义异常类，该类需要继承一个异常接口，类属性包括final类型的连续id、错误码、错误信息、再根据需求写构造方法

### Spring常用注解

- @RestController：修饰类，会返回json数据。（@ResponseBody和@Controller的组合注解）

- @RequestMapping("/path"):修饰类，设置请求路径

- @Autowired:修饰属性，按照类型自动依赖注入

- @PathVariable:修饰参数，将路径值映射到参数上

- @ResponseBody：修饰方法，会返回json数据（类也行

- @RequestBody:修饰参数，该方法将json数据封装到对应参数中

- @Controller @Service @Compont：将类注册到ioc容器中

- @Transaction：开启事务

- @ControllerAdvice就是@Controller 的增强版。使用场景：处理全局异常

- @ExceptionHandler注解我们一般是用来自定义异常的。 可以认为它是一个异常拦截器（处理器）。

  

### 如何使用aop自定义日志？

- 第一步：我们应该定义注解，包括代表各种意义的常量

- 第二步：创建一个切面类，用@component注入容器和用@Aspect来表示这是一个切面
- 第三步：在切面类写一个通知方法，在方法上通过添加注解并通过切入点表达式来表达要对哪些方法进行日志打印，方法参数为JoinPoint
- 第四步：通过JoinPoint这个参数可以获取当前执行的方法名、方法参数等信息，这样就可以根据需求在方法开始前或结束后打印日志



### Spring的bean是线程安全的吗？















## Mysql

### 什么是事务

- 事务就是「一组原子性的SQL查询」，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败

### mysql事务特性

- 原子性：事务统一成功或者失败
- 隔离性：事务与事务之间互不影响
- 持久性：一旦事务提交，则其所做的修改就会永久保存到数据库中
- 一致性：数据库总是从一个一致性的状态转换到另外一个一致性的状态，事务前后数据是不矛盾的，正确的。(事务发生前后的数据总量不发生改变?)

### 事务靠什么保证？

- 原子性：由undolog日志保证，记录了需要回滚的日志信息，回滚时撤销已执行的sql语句
- 隔离性：由MVCC来保证
- 持久性：由redolog日志和内存保证，修改数据后内存和redolog会记录操作，宕机时可恢复
- 一致性：由其他三种特性保证，是事务的目的

### 事务的隔离级别

- 在高并发的状态下，并发事务会产生脏读[^2]，幻读[^3]，不可重复读[^4][^5]，这时需要隔离级别来控制
  - 第一级别-读未提交（READ UNCOMMITTED）：允许一个事务读取另一个事务已提交的数据，可能出现脏读，幻读，不可重复读
  - 第二级别-读已提交（READ COMMITTED）：对方事务提交之后的数据我方可以读取到。这种隔离级别解决了脏读现象。存在的问题：不可重复读，幻读
  - 第三级别-可重复读（REPEATABLE READ）这种隔离级别解决了：不可重复读问题。存在问题：读取到的数据是幻象。
  - 第四级别-序列化/串行化读（SERIALIZABLE），解决所有的问题，但效率低。需要事务排队。

### 什么是快照读和当前读？

- 快照读读取就是读取当前的数据的可见版本，可能是过期数据，不加锁的select都是快照写
- 当前读是读取数据的最新版本，会给返回的数据上锁，保证其他事务不会并发地修改这些数据，比如update、insert、delete、select for update、select lockin share mode（共享锁）都是当前读

### MVCC是什么？

- MVCC是一个多版本并发控制，每个事务都会有一个版本，每次事务都会生成一个新的版本从而解决读写冲突，只在读提交和可重复读中可以使用
- 实现原理有四个东西保证
  - undolog：记录了数据的历史版本
  - readView：事务进行快照读时动态生成的视图，记录了当前的系统中活跃的事务id，控制了哪个历史版本（对当前事务可见？
  - 隐藏字段DB_TRC_ID： 最近修改记录的事务ID 
  - 隐藏字段DB_Roll_PTR： 回滚指针，配合undolog指向数据的上一个版本

### Mysql有哪些索引？







## Redis

### Redis为什么快？

- 完全基于内存操作

- 数据结构简单，操作简单

- 执行命令是单线程的，避免了上下文切换带来的性能问题，避免了锁的问题

- 采用了非阻塞I/O多路复用机制，单线程处理并发请求(一个线程管理多个I/O流)。内部使用了epoll和+时间分离器

  其实Redis不是完全多线程的，在核心的网络模型中是多线程的用来处理并发连接，但是数据的操作都是单线程。Redis坚持单线程是因为Redis是的性能瓶颈是网络延迟而不是CPU，多线程对数据读取不会带来性能提升

### Redis如何实现key的过期删除？

- 定期删除 ：Redis 每隔一段时间从设置过期时间的 key 集合中，随机抽取一些 key ，检查是否过期，如果已经过期做删除处理。

- 惰性删除 ：Redis 在 key 被访问的时候检查 key 是否过期，如果过期则删除。

  - 但是有时候就是那么的巧，既没有被定时器抽取到，又没有被使用，这些数据又如何从内存中消失？没关系，还有内存淘汰机制，当内存不够用时，内存淘汰机制就会上场。

    内存淘汰机制就保证了在redis的内存占用过多的时候，去进行内存淘汰，也就是删除一部分key，保证redis的内存占用率不会过高。

### 缓存穿透问题

缓存击透是有请求频繁查询数据库和缓存中都不存在的数据，请求过多导致性能下降

- 在接口中做基础校验，比如过滤掉id<0的数据
- 当查询不存在的数据时，无论数据存不存在都把他放进缓存里，并设置过期时间，可能会出现短期不一致问题
- 布隆过滤器：在客户端和缓存之间设置过滤器，过滤掉一定不存在的数据请求

### 缓存击穿问题

- 设置热点数据永不过期：对于一些热点数据，可以设置其永不过期，从而避免了热点数据的过期失效问题，但这样会导致缓存中的数据不再与数据库中的数据保持一致，需要考虑到数据一致性的问题。
- 加锁控制并发访问：对于访问量较大的热点数据，可以采用分布式锁机制控制并发访问。例如可以使用 Redis 的 setnx 命令实现分布式锁。
- 使用互斥锁保证缓存数据的唯一生成：对于某些缓存数据需要在缓存中生成，可以使用互斥锁来保证只有一个线程可以生成数据，避免多个线程同时生成数据，从而避免了大量请求同时访问数据库的问题。
- 异步加载数据：当缓存中的数据失效时，可以先返回旧的缓存数据，并在后台异步加载新的数据，从而避免了请求落到数据库上的情况。
- 布隆过滤器：对于访问量非常大的热点数据，可以使用布隆过滤器对访问数据进行过滤，避免请求全部落到数据库上。

### 缓存雪崩问题如何解决

大量的缓存数据的值在同一时间key过期或者redis宕机，大量请求到达了数据库

- 搭建集群保证高可用
- 给数据预热，给redis数据随机设置过期时间
- 给业务添加限流降级，通过锁或者队列来控制线程数量
- 增加多级缓存

### Redis分布式锁的实现原理

- 通过setnx和setex来实现
  - 首先获取分布式锁，用setnx来将key设置为一个特定的值
    - 如果没有获取分布式锁成功，设置时间过一会再请求
  - 获得后用setex设置锁的过期时间，保证锁自动释放，避免死锁的问题

### Redis分布式锁可能会出现哪些问题

- 锁到了超时时间需要自动释放，但是用户操作因为宕机等无法成功操作。可以使用Redison看门狗来解决[^6]，对key进行自动续期
- 添加锁和释放锁可能不是一个线程的，可以在value中加入UUID，删除的时候进行验证。删除锁和验证锁也不是一个原子操作，可以使用lua脚本使之成为袁紫心该操作

- 不可重入。可以使用Redision解决（实现机制类似AQS,计数）
- redis集群下主节点宕机导致锁丢失。使用红锁解决



### Redis的数据类型和应用场景

- String，可用来缓存数据，登录次数、访问人数、计数器之类

- Hash，用来缓存数据，购物车啊，一个键值对
- List，用来做消息队列，pop是原子性的一定程度保证线程安全
- Set，可以去重，一个用户只能参加一次活动；交集共友
- SortSet，做排行榜



### Redis的集群方案

- 主从模式。一个master节点和多个slave节点，主节点宕机了salve自动变成主节点
- 哨兵模式。在主从模式的基础上添加哨兵节点或者哨兵集群，他们会监控master的健康状态，当master节点失效后会通过投票机制来选出一个slave来成为新的master节点
- 分片集群。解决了并发写的问题，有多个master，分别存储了不同的数据，每个请求都会被正确的发送到相应的节点

### Redis内存淘汰策略

- 当内存不足时按设定好的策略进行淘汰，策略有
  - (1)淘汰最久没使用的
  - （2）淘汰一段时间内最少使用的
  - （3）淘汰快要过期的

## 计算机网络系列

### TCP/IP模型

- 五层模型：物理层-数据链路层-网络层-传输层-应用层



#### 浏览器输入网址之后做了什么？

- 










[^2]: 在事务A修改数据之后提交数据之前，这时另一个事务B来读取数据，如果不加控制，事务B读取到A修改前的数据，之后A又对数据做了修改再提交，则B读到的数据是脏数据，此过程称为脏读Dirty Read。
[^3]: 事务A在按查询条件读取某个范围的记录时，事务B又在该范围内插入了新的满足条件的记录，当事务A再次按条件查询记录时，会产生新的满足条件的记录（幻行 Phantom Row）
[^4]: 一个事务内在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了变更、或者某些记录已经被删除了
[^5]:  **不可重复读**的重点是修改： 在同一事务中，同样的条件，第一次读的数据和第二次读的「数据不一样」。（因为中间有其他事务提交了修改）; **幻读**的重点在于新增或者删除： 在同一事务中，同样的条件，第一次和第二次读出来的「记录数不一样」。（因为中间有其他事务提交了插入/删除

 
