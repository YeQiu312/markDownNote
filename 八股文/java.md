##  Java基础

### 接口和抽象类的区别

- 相似点：

  1. 接口和抽象类都不能实例化[^1]

  2. 实现接口和继承抽象类的普通的子类都必须实现这些抽象方法
- 不同点：

  1. 接口类不能包含方法，抽象类可以包含普通代码块和普通方法
  2. 抽象类内部可以有任何类型的成员变量，但是接口类只能有 Public static final 类型的变量，并且必须赋值
  3. 抽象类可以有构造方法，接口不行

[^1]:Demo demo = new Demo(); 通常把这条语句的动作称之为创建一个对象，也就是实例化，其实，它包含了四个动作。(1）右边的“new Demo”，是以Demo类为模板，在堆空间里创建一个Demo类对象（也简称为Demo对象）。(2）末尾的()意味着，在对象创建后，立即调用Demo类的构造函数，对刚生成的对象进行初始化。构造函数是肯定有的。如果你没写，Java会给你补上一个默认的构造函数。(3）左边的“Demo demo”创建了一个Demo 类引用变量。所谓Demo类引用，就是以后可以用来指向Demo对象的对象引用。(4）“=”操作符使对象引用指向刚创建的那个Demo对象。

### 重写和重载的区别

- 重载发生在同一个类中，方法名、参数名、返回类型都相同，权限修饰符可以不一样
- 重写发生在子类当中，方法名、参数名、返回类型都相同，权限修饰符要大于父类方法，声明异常要小于父类方法，final和private修饰的方法不可以重写

###  ==和equals的区别

- ==比较的是引用类型，即内存地址；equals比较的是值
- equals是object类的方法，本质和==一样。但有些类重写了equals方法，比如String的equals被重写后比较的就是字符的值；重写equals后也必须重写hashcode()方法

###  异常处理的机制

- 使用try、catch、finally捕获异常，finally中的代码一定会执行，捕获到异常后程序会继续执行
- 使用throws声明该方法可能会抛出的异常，出现异常后程序终止

### HashMapd原理

- HashMap特点是key不能重复，可以为null,线程不安全（在Jdk1.8以后使用的是数组+链表+红黑树）
- 扩容机制：默认容量是16，负载因子为0.75，当元素个数超过 容量×负载因子，HashMap会创建一个新大小为原来两倍的数组，再将原来数组中的数据复制到新数组中。当数组长度达到64、有一个桶大于八的时候或者链表长度大于8时，链表转为红黑树
  - 链路过长会导致查询效率降低，所以会转为红黑树
    - 在HashMap中，桶（bucket）是指哈希表的存储位置。每个桶中可以存储一个或多个键值对，用于解决哈希冲突。桶的实现方式可以是链表、红黑树等数据结构。

- HashMap存取原理：
  1. 计算key的hash值，然后进行二次hash，根据二次hash的结果找到对应的索引位置。
  2. 如果这个位置有值，进行equals比较，为true则取代该元素，结果为false就用 高低位平移法 将节点插入链表（JDK8以前使用头插法，但是头插法在并发扩容时可能会造成环形链表或数据丢失，而高低位平移发会发生数据覆盖的情况）

### HashMap冲突怎么解决？（正确性存疑）

1. 链式解决冲突（Separate Chaining）：将每个槽都设置为链表的头结点，如果发生哈希冲突，则将新的键值对插入到对应槽的链表中。这种方式可以保证所有键值对都能够被存储，但是当链表过长时，会导致查找效率降低。
2. 在Java中，HashMap使用的是链式寻址法（尾插法）的方式，每个槽都是一个链表头结点，如果发生冲突，则将新的键值对插入到对应槽的链表中。当链表长度达到一定阈值时，会将链表转换为红黑树，以提高查询效率。

### 想要线程安全的HashMap怎么办？





### Static 修饰的方法可以被继承吗？final呢？



### 深拷贝和浅拷贝的区别

- 浅拷贝是复制了某个对象的引用，不复制对象本身，新旧对象共享一个内存空间，比如clone()方法、copy()方法
- 深拷贝是会创造一个一模一样的对象，新旧对象并不共享同一个内存空间，新对象的修改不会改变原来的对象，可以使用序列化和反序列化来深拷贝一个对象
  - 在实际开发中，也可以使用第三方库来实现深拷贝。常用的库包括 Apache Commons BeanUtils 和 Spring Framework 中的 BeanUtils。

### 什么是序列化和反序列化？

- 序列化：把数据结构或对象转化为二进制数据

###  权限修饰符应该怎么使用？

- 从作用域来看，public能够使用所有的情况。但是大家在工作的时候，又不会真正全部都使用public，那么到底什么情况该用什么修饰符呢？

- 属性通常使用private封装起来。
- 方法一般使用public用于被调用。
- 会被子类继承的方法，通常使用protected。
- default用的不多，一般新手会用default，因为还不知道有修饰符这个东西。
- 再就是作用范围最小原则：

### 面向对象和面向过程的区别

- 面向对象有继承、封装、多态
  - 相比于面向过程更容易维护、拓展、服用
  - 需要更多的开销，性能更低。因为类调用要实例化

### 多态的作用？

- 多态即同一个方法可以在不同的子类中有不同的实现。
- 多态有继承、重写、父类引用指向子类对象。可以解耦，增加可扩充性和灵活性

### 什么是反射

- 反射是通过获取类的class对象，然后动态的获取到这个类的内部结构，动态的去操作类的属性和方法。
- 应用场景有：要操作权限不够的类属性和方法时、实现自定义注解时、动态加载第三方jar包时、按需加载类，节省编译和初始化时间；
  获取class对象的方法有：class.forName(类路径)，类.class()，对象的getClass（）

### Java创建对象得五种方式?

(1)new关键字  (2)Class.newInstance (3)Constructor.newInstance

(4)Clone方法  (5)反序列化

## Java多线程篇

### 进程和线程的区别

- 进程：系统运行的基本单位，每个进程都是独立的
- 线程：独立运行的最小单位，线程可以相互影响，一个进程可以包含多个线程并且可以共享系统资源
- 进程间通过管道、共享内存、信息量机制、消息队列通信

### 什么是线程上下文切换

当一个线程被cpu剥夺使用权切换到另个线程去执行的时候

### 什么是死锁

死锁就是多个线程在执行过程中，因为争夺资源相互等待的局面

### 死锁的必要条件

- 互斥条件：一个资源只能由一个线程去执行
  - 这个一般是不能破坏的，线程本身就是通过互斥来解决线程安全问题

- 不可抢占：不能强行剥夺线程持有的资源
  - 申请资源的时候申请不到就放掉手上的资源

- 请求和保持：在请求其他资源的同时保持手上的资源不放
  - 一次性去申请所需的资源

- 循环等待：在相互等待资源的过程中形成一个闭环
  - 按照顺序申请资源


想要预防死锁，破坏其中一个破坏其中一个条件即可，比如使用定时锁、尽量让线程用相同的加锁顺序，还可以用银行家算法可以预防死锁



## JVM篇

### JVM运行时数据区（内存篇）

- 线程私有区：
  - 虚拟机栈：每次调用方法的时候都会在虚拟机栈里产生一个栈帧，包含了方法的方法参数、局部变量、方法出口等信息，方法执行完毕之后就会释放栈帧
  - 本地方法帧：为native修饰的本地方法提供的空间，在hotspot中与虚拟机合二为一
  - 程序计数器：记录了指令执行的地址，方便线程切换之后继续执行代码
- 线程共享区：
  - 堆内存：
  - 方法去：

### 什么情况下内存会溢出

- 堆内存溢出
  - 对象创建出来但是没有被收回
  - 加载的类过多
  - 虚拟机栈的线程越来越多的时候
- 栈内存溢出
  - 方法调用次数过多，一般是递归不当造成

## 常用开发框架系列

###  什么是Spring？

- Spring是个轻量级的框架，通过IOC来达到解耦的目的，通过AOP将业务逻辑和系统服务分离进行内聚性开发，缺点是配置组件比较繁琐。

###  IOC是什么？

- IOC是一种控制反转的思想，将对象的创建和调用（new对象）交给容器进行管理，减少方法之间的依赖，避免后期对代码进行修改时要到回相应的方法来new对象调用其他方法。
  - 创建bean的方法可以使用：@bean、@componte、xml的方式
  - 在创建一个bean之后需要对他的属性进行填充，我们通常会用@Autowire直接填充依赖注入，他是有限按照类型进行匹配的

### AOP是什么？

- AOP是面向切面编程，将与业务不相关的但是许多业务又要被调用的代码抽离出来，本质是在对原有代码不进行改动的情况下去进行功能增强
  - SpringAOP是基于动态代理实现的，一种是jdk动态代理，一种是cglib代理
    - jdk代理是利用反射来实现的，是调用反射包中的proxy类中的newproxyInstance方法来返回代理对象。这个方法有三个参数，一个是用于加载代理类的类加载器，一个是被代理类实现的接口的class数组和一个用于增强方法的InvocaHandler实现类
    - cglib代理是利用asm开源包来实现的，是把被代理类的class文件加载进来，通过修改他的字节码生成子类来处理

### 如何定义一个全局异常处理类？

- 在自定义的全局异常处理类的类上添加@ControllerAdvice注解，然后定义一些用于捕捉不同异常类型的方法，在这些方法上边添加@ExceptionHandle(value=异常类型.class)和@ResponseBody注解，方法参数是HttpServletRequest和异常类型，然后将异常消息进行处理
- 如果需要自定义异常类的活，就写一个自定义异常类，该类需要继承一个异常接口，类属性包括final类型的连续id、错误码、错误信息、再根据需求写构造方法

### Spring常用注解

- @RestController：修饰类，会返回json数据。（@ResponseBody和@Controller的组合注解）

- @RequestMapping("/path"):修饰类，设置请求路径

- @Autowired:修饰属性，按照类型自动依赖注入

- @PathVariable:修饰参数，将路径值映射到参数上

- @ResponseBody：修饰方法，会返回json数据（类也行

- @RequestBody:修饰参数，该方法将json数据封装到对应参数中

- @Controller @Service @Compont：将类注册到ioc容器中

- @Transaction：开启事务

- @ControllerAdvice就是@Controller 的增强版。使用场景：处理全局异常

- @ExceptionHandler注解我们一般是用来自定义异常的。 可以认为它是一个异常拦截器（处理器）。

  

### 如何使用aop自定义日志？

- 第一步：我们应该定义注解，包括代表各种意义的常量

- 第二步：创建一个切面类，用@component注入容器和用@Aspect来表示这是一个切面
- 第三步：在切面类写一个通知方法，在方法上通过添加注解并通过切入点表达式来表达要对哪些方法进行日志打印，方法参数为JoinPoint
- 第四步：通过JoinPoint这个参数可以获取当前执行的方法名、方法参数等信息，这样就可以根据需求在方法开始前或结束后打印日志



### Spring的bean是线程安全的吗？



### mybatis #{}和${}的区别

在 MyBatis 中，`#{}` 和 `${}` 都是用来处理 SQL 中的参数的，但是它们的处理方式不同。

`#{}` 会把传入的参数自动封装成一个 `Map` 对象，然后把 `#{}` 替换成 `?`，并把参数的值设置到 `PreparedStatement` 中。同时，`#{}` 还可以防止 SQL 注入，因为 `#{}` 会对参数进行预编译处理。

`${}` 会把传入的参数直接拼接到 SQL 语句中，而不是使用预编译处理。这意味着在使用 `${}` 时，应该非常小心，因为容易导致 SQL 注入的问题。

因此，在 MyBatis 中，一般建议使用 `#{}` 来处理 SQL 中的参数，除非有非常特殊的情况需要使用 `${}`。

### Mybatis的二级缓存是什么？









## Mysql

### MyIsAm(“my-z[ei]m”)和InnoDB(“in-no-db”)是什么？

- MyISAM和InnoDB是MySQL数据库中两种不同的存储引擎。

- MyISAM是MySQL的默认存储引擎，它支持全文本索引、压缩表等特性，适合于大量查询的应用场景。它的优点是操作速度快，适用于大部分的web应用。

- InnoDB则是MySQL的另一种存储引擎，它支持事务、行级锁定、外键等特性，适合于需要高并发读写、数据一致性要求高的应用场景。它的优点是支持事务，保证数据的一致性和完整性，适用于高并发和数据安全性要求较高的场景，如金融、电商等领域。

- 因此，在选择存储引擎时，需要根据实际应用场景和需求来决定。如果是大量查询的应用场景，可以选择MyISAM；如果是高并发读写、数据一致性要求高的应用场景，可以选择InnoDB。同时，还需要考虑到数据库的大小、性能、安全等因素，选择最适合自己业务的存储引擎。

### MyIsAm和InnoDB的区别

- InnoDB有三大特性，事务，外键，行级锁，这些都是MyIsAm不支持的
- InnoDB是聚簇索引，MyIAm是非聚簇索引

### 什么是事务

- 事务就是「一组原子性的SQL查询」，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败

### mysql事务特性

- 原子性：事务统一成功或者失败
- 隔离性：事务与事务之间互不影响
- 持久性：一旦事务提交，则其所做的修改就会永久保存到数据库中
- 一致性：数据库总是从一个一致性的状态转换到另外一个一致性的状态，事务前后数据是不矛盾的，正确的。(事务发生前后的数据总量不发生改变?)

### 事务靠什么保证？

- 原子性：由undolog日志保证，记录了需要回滚的日志信息，回滚时撤销已执行的sql语句
- 隔离性：由MVCC来保证
- 持久性：由redolog日志和内存保证，修改数据后内存和redolog会记录操作，宕机时可恢复
- 一致性：由其他三种特性保证，是事务的目的

### 事务的隔离级别

- 在高并发的状态下，并发事务会产生脏读[^2]，幻读[^3]，不可重复读[^4][^5]，这时需要隔离级别来控制
  - 第一级别-读未提交（READ UNCOMMITTED）：允许一个事务读取另一个事务已提交的数据，可能出现脏读，幻读，不可重复读
  - 第二级别-读已提交（READ COMMITTED）：对方事务提交之后的数据我方可以读取到。这种隔离级别解决了脏读现象。存在的问题：不可重复读，幻读
  - 第三级别-可重复读（REPEATABLE READ）这种隔离级别解决了：不可重复读问题。存在问题：读取到的数据是幻象。
  - 第四级别-序列化/串行化读（SERIALIZABLE），解决所有的问题，但效率低。需要事务排队。

### 什么是快照读和当前读？

- 快照读读取就是读取当前的数据的可见版本，可能是过期数据，不加锁的select都是快照写
- 当前读是读取数据的最新版本，会给返回的数据上锁，保证其他事务不会并发地修改这些数据，比如update、insert、delete、select for update、select lockin share mode（共享锁）都是当前读

### MVCC是什么？

- MVCC是一个多版本并发控制，每个事务都会有一个版本，每次事务都会生成一个新的版本从而解决读写冲突，只在读提交和可重复读中可以使用
- 实现原理有四个东西保证
  - undolog：记录了数据的历史版本
  - readView：事务进行快照读时动态生成的视图，记录了当前的系统中活跃的事务id，控制了哪个历史版本（对当前事务可见？
  - 隐藏字段DB_TRC_ID： 最近修改记录的事务ID 
  - 隐藏字段DB_Roll_PTR： 回滚指针，配合undolog指向数据的上一个版本

### Mysql有哪些索引？







## Redis

### Redis为什么快？

- 完全基于内存操作

- 数据结构简单，操作简单

- 执行命令是单线程的，避免了上下文切换带来的性能问题，避免了锁的问题

- 采用了非阻塞I/O多路复用机制，单线程处理并发请求(一个线程管理多个I/O流)。内部使用了epoll和+时间分离器

  其实Redis不是完全多线程的，在核心的网络模型中是多线程的用来处理并发连接，但是数据的操作都是单线程。Redis坚持单线程是因为Redis是的性能瓶颈是网络延迟而不是CPU，多线程对数据读取不会带来性能提升

### redis中存储数据需要进行序列化和反序列化吗

- 是的，往 Redis 中存储数据需要进行序列化和反序列化。Redis 是一个内存数据库，所有的数据都存储在内存中。在存储数据时，我们需要将数据转换为二进制格式，然后将二进制数据存储到 Redis 中。这个过程就是序列化。

  - 在读取数据时，我们需要将从 Redis 中读取出来的二进制数据转换回原来的数据格式。这个过程就是反序列化。只有进行反序列化，我们才能对从 Redis 中读取出来的数据进行操作和处理。

  - 在 Redis 中，常用的序列化方式包括 JSON 序列化、Java 序列化、Hessian 序列化等。不同的序列化方式有不同的优缺点，需要根据实际需求进行选择。但无论选择哪种序列化方式，都需要进行序列化和反序列化。

### Redis如何实现key的过期删除？

- 定期删除 ：Redis 每隔一段时间从设置过期时间的 key 集合中，随机抽取一些 key ，检查是否过期，如果已经过期做删除处理。

- 惰性删除 ：Redis 在 key 被访问的时候检查 key 是否过期，如果过期则删除。

  - 但是有时候就是那么的巧，既没有被定时器抽取到，又没有被使用，这些数据又如何从内存中消失？没关系，还有内存淘汰机制，当内存不够用时，内存淘汰机制就会上场。

    内存淘汰机制就保证了在redis的内存占用过多的时候，去进行内存淘汰，也就是删除一部分key，保证redis的内存占用率不会过高。

### 缓存穿透问题

缓存击透是有请求频繁查询数据库和缓存中都不存在的数据，请求过多导致性能下降

- 在接口中做基础校验，比如过滤掉id<0的数据
- 当查询不存在的数据时，无论数据存不存在都把他放进缓存里，并设置过期时间，可能会出现短期不一致问题
- 布隆过滤器：在客户端和缓存之间设置过滤器，过滤掉一定不存在的数据请求

### 缓存击穿问题

- 设置热点数据永不过期：对于一些热点数据，可以设置其永不过期，从而避免了热点数据的过期失效问题，但这样会导致缓存中的数据不再与数据库中的数据保持一致，需要考虑到数据一致性的问题。
- 加锁控制并发访问：对于访问量较大的热点数据，可以采用分布式锁机制控制并发访问。例如可以使用 Redis 的 setnx 命令实现分布式锁。
- 使用互斥锁保证缓存数据的唯一生成：对于某些缓存数据需要在缓存中生成，可以使用互斥锁来保证只有一个线程可以生成数据，避免多个线程同时生成数据，从而避免了大量请求同时访问数据库的问题。
- 异步加载数据：当缓存中的数据失效时，可以先返回旧的缓存数据，并在后台异步加载新的数据，从而避免了请求落到数据库上的情况。
- 布隆过滤器：对于访问量非常大的热点数据，可以使用布隆过滤器对访问数据进行过滤，避免请求全部落到数据库上。

### 缓存雪崩问题如何解决

大量的缓存数据的值在同一时间key过期或者redis宕机，大量请求到达了数据库

- 搭建集群保证高可用
- 给数据预热，给redis数据随机设置过期时间
- 给业务添加限流降级，通过锁或者队列来控制线程数量
- 增加多级缓存

### Redis分布式锁的实现原理

- 通过setnx和setex来实现
  - 首先获取分布式锁，用setnx来将key设置为一个特定的值
    - 如果没有获取分布式锁成功，设置时间过一会再请求
  - 获得后用setex设置锁的过期时间，保证锁自动释放，避免死锁的问题

### Redis分布式锁可能会出现哪些问题

- 锁到了超时时间需要自动释放，但是用户操作因为宕机等无法成功操作。可以使用Redison看门狗来解决[^6]，对key进行自动续期
- 添加锁和释放锁可能不是一个线程的，可以在value中加入UUID，删除的时候进行验证。删除锁和验证锁也不是一个原子操作，可以使用lua脚本使之成为袁紫心该操作

- 不可重入。可以使用Redision解决（实现机制类似AQS,计数）
- redis集群下主节点宕机导致锁丢失。使用红锁解决



### Redis的数据类型和应用场景

- String，可用来缓存数据，登录次数、访问人数、计数器之类

- Hash，用来缓存数据，购物车啊，一个键值对
- List，用来做消息队列，pop是原子性的一定程度保证线程安全
- Set，可以去重，一个用户只能参加一次活动；交集共友
- SortSet，做排行榜



### Redis的集群方案

- 主从模式。一个master节点和多个slave节点，主节点宕机了salve自动变成主节点
- 哨兵模式。在主从模式的基础上添加哨兵节点或者哨兵集群，他们会监控master的健康状态，当master节点失效后会通过投票机制来选出一个slave来成为新的master节点
- 分片集群。解决了并发写的问题，有多个master，分别存储了不同的数据，每个请求都会被正确的发送到相应的节点

### Redis内存淘汰策略

- 当内存不足时按设定好的策略进行淘汰，策略有
  - (1)淘汰最久没使用的
  - （2）淘汰一段时间内最少使用的
  - （3）淘汰快要过期的

### redis都是单线程操作吗

- Redis在处理网络io和处理读写操作是单线程
  - 具体来说，Redis 通过一个单独的线程监听客户端请求，当有新的请求进来时，Redis 会将请求放入请求队列中，等待处理。然后 Redis 会从队列中取出请求，交给数据处理线程处理，处理完之后再将结果返回给客户端。在这个过程中，网络 IO 和数据处理都是单线程操作，这样可以避免多线程并发带来的问题，如死锁、竞争条件等。
  - 多线程也有。后台线程用于定期执行一些任务，如数据持久化、清除过期数据等

## 未归类

### IO、NIO、BIO、AIO有什么区别？

- IO是对磁盘或者网络数据的读写，进程读取一次IO请求分为两个阶段：
  - 等待数据到达内核缓存区和内核

## 计算机网络系列

### TCP/IP模型

- 讲讲TCP/IP
  - 对于同一台的设备上的进程通信会有很多方式，比如管道，消息队列、共享内存、信号等方式；而对不同的设备通信就要有相关的兼容不同设备的网络协议

- 五层模型：物理层-数据链路层-网络层-传输层-应用层

  - 应用层
    - 最上层，只专注于为用户提供应用功能，不关注数据如何传输
    - 在操作系统中是用户态，传输层以下是内核态

  - 传输层（不涉及从一个设备传输到另一个设备）

    ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E5%BA%94%E7%94%A8%E5%B1%82.png)

    - 传输层有两个协议，一个是TCP，一个是UDP
      - TCP拥有很多特性。**流量控制，超时重传，拥塞控制**等等
      - UDP更简单一点，只负责发送数据包，不能保证数据是否能够抵达对方。因此相对而言他的速度更快一些，实时性更强。
      - UDP也可以实现可靠传输，要把tcp的特性在应用层上实现
    - 如果传输的数据包非常大，超过了TCP报文的最大长度，就会讲数据包**分块**，被称为**TCP段**，即使没有被传输成功，那只需要传输丢失的字段即可
    - 传输层要传输数据，也相应的也出现了**端口**，如8080等

    ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/TCP%E6%AE%B5.png)

  - 网络层

    ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E7%BD%91%E7%BB%9C%E5%B1%82.png)

    

    - IP 协议：会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会**再次进行分片**，得到一个即将发送到网络的 IP 报文。
      - IP 地址分成两种意义：
        - 一个是**网络号**，负责标识该 IP 地址是属于哪个「子网」的；
        - 一个是**主机号**，负责标识同一「子网」下的不同主机；
    - 路由
    - **IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘**。

  - 网络接口层

    - 加Mac头部
    - 网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。

### 三次握手

- 一开始，客户端和服务端都处于 `CLOSED` 状态。先是服务端主动监听某个端口，处于 `LISTEN` 状态。
- 然后客户端主动发起连接 `SYN`，头部会携带一个随机初始化的序号放在TCP首部（的序号字段中），之后处于 `SYN-SENT` 状态。
- 服务端收到发起的连接，也随机初始化一个序号放在TCP首部（的序号字段中），返回 `SYN`，并且 `ACK` 客户端的 `SYN`，把 `SYN` 和 `ACK` 标志位置为 `1`，之后处于 `SYN-RCVD` 状态。
- 客户端收到服务端发送的 `SYN` 和 `ACK` 之后，首先该应答报文 TCP 首部 `ACK` 标志位置为 `1` ，其次「确认应答号」字段填入 `server_isn + 1`，发送对 `SYN` 确认的 `ACK`，之后处于 `ESTABLISHED` 状态，因为它一发一收成功了。
- 服务端收到 `ACK` 的 `ACK` 之后，处于 `ESTABLISHED` 状态，因为它也一发一收了

简单回答

1. 客户端向服务器端发送连接请求报文（SYN）。
2. 服务器端收到连接请求报文，如果同意连接，则会向客户端发送连接确认报文（SYN+ACK）。
3. 客户端收到服务器端的确认报文，再向服务器端发送确认报文（ACK）。



- 从上面的过程可以发现**第三次握手是可以携带数据的，前两次握手是不可以携带数据的**，这也是面试常问的题。数据是携带自己的数据。这个数据通常为空，也就是说第三次握手不是必须要携带数据的

  一旦完成三次握手，双方都处于 `ESTABLISHED` 状态，此时连接就已建立完成，客户端和服务端就可以相互发送数据了

![TCP 三次握手](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png)



### 为什么是三次握手？不是两次、四次？

不使用「两次握手」和「四次握手」的原因：

- 「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；
- 「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数

------------------------------------------------

- 三次握手才可以阻止重复历史连接的初始化（主要原因）
  - 二次的话会在第一次握手后服务端就进入连接状态，无阻止历史连接，如果是历史连接就会占用资源，浪费数据
- 三次握手才可以同步双方的初始序列号
  - 接收方可以去除重复的数据；
  - 接收方可以根据数据包的序列号按序接收；
  - 可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；
    - 四次握手也可以，中间两步数syn和
- 三次握手才可以避免资源浪费

### 浏览器输入网址之后做了什么？

- 解析URL生成发给Web服务器的请求信息
- 通过浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统将消息发送给 `Web` 服务器
- ...





## 工具类

### UUID是什么

UUID（Universally Unique Identifier，通用唯一识别码）是指在一台机器上生成的数字，它保证对于不同的机器和时间戳，生成的数字是唯一的。UUID是由一组32位的16进制数字组成，表示为8-4-4-4-12的格式。

UUID通常用于在分布式系统中为每个实体分配唯一标识符，例如数据库中的记录、消息队列中的消息等等。Java提供了UUID类来生成符合标准的UUID，可以使用randomUUID()方法生成一个新的随机UUID。






[^2]: 在事务A修改数据之后提交数据之前，这时另一个事务B来读取数据，如果不加控制，事务B读取到A修改前的数据，之后A又对数据做了修改再提交，则B读到的数据是脏数据，此过程称为脏读Dirty Read。
[^3]: 事务A在按查询条件读取某个范围的记录时，事务B又在该范围内插入了新的满足条件的记录，当事务A再次按条件查询记录时，会产生新的满足条件的记录（幻行 Phantom Row）
[^4]: 一个事务内在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了变更、或者某些记录已经被删除了
[^5]:  **不可重复读**的重点是修改： 在同一事务中，同样的条件，第一次读的数据和第二次读的「数据不一样」。（因为中间有其他事务提交了修改）; **幻读**的重点在于新增或者删除： 在同一事务中，同样的条件，第一次和第二次读出来的「记录数不一样」。（因为中间有其他事务提交了插入/删除

 
