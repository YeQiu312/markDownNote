##  Java基础

### 接口和抽象类的区别

- 相似点：

  1. 接口和抽象类都不能实例化[^1]

  2. 实现接口和继承抽象类的普通的子类都必须实现这些抽象方法
- 不同点：

  1. 接口类不能包含方法，抽象类可以包含普通代码块和普通方法
  2. 抽象类内部可以有任何类型的成员变量，但是接口类只能有 Public static final 类型的变量，并且必须赋值
  3. 抽象类可以有构造方法，接口不行

[^1]:Demo demo = new Demo(); 通常把这条语句的动作称之为创建一个对象，也就是实例化，其实，它包含了四个动作。(1）右边的“new Demo”，是以Demo类为模板，在堆空间里创建一个Demo类对象（也简称为Demo对象）。(2）末尾的()意味着，在对象创建后，立即调用Demo类的构造函数，对刚生成的对象进行初始化。构造函数是肯定有的。如果你没写，Java会给你补上一个默认的构造函数。(3）左边的“Demo demo”创建了一个Demo 类引用变量。所谓Demo类引用，就是以后可以用来指向Demo对象的对象引用。(4）“=”操作符使对象引用指向刚创建的那个Demo对象。

### 重写和重载的区别

- 重载发生在同一个类中，方法名、参数名、返回类型都相同，权限修饰符可以不一样
- 重写发生在子类当中，方法名、参数名、返回类型都相同，权限修饰符要大于父类方法，声明异常要小于父类方法，final和private修饰的方法不可以重写

###  ==和equals的区别

- ==比较的是引用类型，即内存地址；equals比较的是值
- equals是object类的方法，本质和==一样。但有些类重写了equals方法，比如String的equals被重写后比较的就是字符的值；重写equals后也必须重写hashcode()方法

###  异常处理的机制

- 使用try、catch、finally捕获异常，finally中的代码一定会执行，捕获到异常后程序会继续执行
- 使用throws声明该方法可能会抛出的异常，出现异常后程序终止

### HashMapd原理

- HashMap特点是key不能重复，可以为null,线程不安全（在Jdk1.8以后使用的是数组+链表+红黑树）
- 扩容机制：默认容量是16，负载因子为0.75，当元素个数超过 容量×负载因子，HashMap会创建一个新大小为原来两倍的数组，再将原来数组中的数据复制到新数组中。当数组长度达到64并且链表长度大于8时，链表转为红黑树
- HashMap存取原理：
  1. 计算key的hash值，然后进行二次hash，根据二次hash的结果找到对应的索引位置。
  2. 如果这个位置有值，进行equals比较，为true则取代该元素，结果为false就用 高低位平移法 将节点插入链表（JDK8以前使用头插法，但是头插法在并发扩容时可能会造成环形链表或数据丢失，而高低位平移发会发生数据覆盖的情况）

### 想要线程安全的HashMap怎么办？





###  权限修饰符应该怎么使用？

从作用域来看，public能够使用所有的情况。但是大家在工作的时候，又不会真正全部都使用public，那么到底什么情况该用什么修饰符呢？

属性通常使用private封装起来。
方法一般使用public用于被调用。
会被子类继承的方法，通常使用protected。
default用的不多，一般新手会用default，因为还不知道有修饰符这个东西。
再就是作用范围最小原则：





## 常用开发框架系列

###  什么是Spring？

- Spring是个轻量级的框架，通过IOC来达到解耦的目的，通过AOP将业务逻辑和系统服务分离进行内聚性开发，缺点是配置组件比较繁琐。

###  IOC是什么？

- IOC是一种控制反转的思想，将对象的创建和调用（new对象）交给容器进行管理，减少方法之间的依赖，避免后期对代码进行修改时要到回相应的方法来new对象调用其他方法。
  - 创建bean的方法可以使用：@bean、@componte、xml的方式
  - 在创建一个bean之后需要对他的属性进行填充，我们通常会用@Autowire直接填充依赖注入，他是有限按照类型进行匹配的

### AOP是什么？

- AOP是面向切面编程，将与业务不相关的但是许多业务又要被调用的代码抽离出来，本质是在对原有代码不进行改动的情况下去进行功能增强
  - SpringAOP是基于动态代理实现的，一种是jdk动态代理，一种是cglib代理
    - jdk代理是利用反射来实现的，是调用反射包中的proxy类中的newproxyInstance方法来返回代理对象。这个方法有三个参数，一个是用于加载代理类的类加载器，一个是被代理类实现的接口的class数组和一个用于增强方法的InvocaHandler实现类
    - cglib代理是利用asm开源包来实现的，是把被代理类的class文件加载进来，通过修改他的字节码生成子类来处理

### 如何定义一个全局异常处理类？

- 在自定义的全局异常处理类的类上添加@ControllerAdvice注解，然后定义一些用于捕捉不同异常类型的方法，在这些方法上边添加@ExceptionHandle(value=异常类型.class)和@ResponseBody注解，方法参数是HttpServletRequest和异常类型，然后将异常消息进行处理
- 如果需要自定义异常类的活，就写一个自定义异常类，该类需要继承一个异常接口，类属性包括final类型的连续id、错误码、错误信息、再根据需求写构造方法

### Spring常用注解

- @RestController：修饰类，会返回json数据。（@ResponseBody和@Controller的组合注解）
- @RequestMapping("/path"):修饰类，设置请求路径
- @Autowired:修饰属性，按照类型自动依赖注入
- @PathVariable:修饰参数，将路径值映射到参数上
- @ResponseBody：修饰方法，会返回json数据（类也行
- @RequestBody:修饰参数，该方法将json数据封装到对应参数中
- @Controller @Service @Compont：将类注册到ioc容器中
- @Transaction：开启事务
- @ControllerAdvice就是@Controller 的增强版。使用场景：处理全局异常
- @ExceptionHandler注解我们一般是用来自定义异常的。 可以认为它是一个异常拦截器（处理器）。

### Spring的bean是线程安全的吗？















## Mysql

### 什么是事务

- 事务就是「一组原子性的SQL查询」，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败

### mysql事务特性

- 原子性：事务统一成功或者失败
- 隔离性：事务与事务之间互不影响
- 持久性：一旦事务提交，则其所做的修改就会永久保存到数据库中
- 一致性：数据库总是从一个一致性的状态转换到另外一个一致性的状态，事务前后数据是不矛盾的，正确的。(事务发生前后的数据总量不发生改变?)

### 事务靠什么保证？

- 原子性：由undolog日志保证，记录了需要回滚的日志信息，回滚时撤销已执行的sql语句
- 隔离性：由MVCC来保证
- 持久性：由redolog日志和内存保证，修改数据后内存和redolog会记录操作，宕机时可恢复
- 一致性：由其他三种特性保证，是事务的目的

### 事务的隔离级别

- 在高并发的状态下，并发事务会产生脏读[^2]，幻读[^3]，不可重复读[^4][^5]，这时需要隔离级别来控制
  - 第一级别-读未提交（READ UNCOMMITTED）：允许一个事务读取另一个事务已提交的数据，可能出现脏读，幻读，不可重复读
  - 第二级别-读已提交（READ COMMITTED）：对方事务提交之后的数据我方可以读取到。这种隔离级别解决了脏读现象。存在的问题：不可重复读，幻读
  - 第三级别-可重复读（REPEATABLE READ）这种隔离级别解决了：不可重复读问题。存在问题：读取到的数据是幻象。
  - 第四级别-序列化/串行化读（SERIALIZABLE），解决所有的问题，但效率低。需要事务排队。







## Redis










[^2]: 在事务A修改数据之后提交数据之前，这时另一个事务B来读取数据，如果不加控制，事务B读取到A修改前的数据，之后A又对数据做了修改再提交，则B读到的数据是脏数据，此过程称为脏读Dirty Read。
[^3]: 事务A在按查询条件读取某个范围的记录时，事务B又在该范围内插入了新的满足条件的记录，当事务A再次按条件查询记录时，会产生新的满足条件的记录（幻行 Phantom Row）
[^4]: 一个事务内在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了变更、或者某些记录已经被删除了
[^5]:  **不可重复读**的重点是修改： 在同一事务中，同样的条件，第一次读的数据和第二次读的「数据不一样」。（因为中间有其他事务提交了修改）; **幻读**的重点在于新增或者删除： 在同一事务中，同样的条件，第一次和第二次读出来的「记录数不一样」。（因为中间有其他事务提交了插入/删除

 
