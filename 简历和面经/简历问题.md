### 2022.3.27 简历问题预备

#### 自我介绍

各位面试官好，我是叶润畅，目前广东工业大学信息管理与信息系统专业大三在读。

目前主要使用的语言是Java，同时对go语言也有一些了解。

目前主要做过两个项目，都是自己独立完成的。第一个是基于springboot开发的一个后台管理系统,主要是

另一个是项目是仿抖音的项目，实现了基础功能项：视频流接口、视频投稿、个人主页。社交功能包括关系列表和聊天。本来是一个团队的项目，后来队友都跑路了，所以这个项目是我独立做的。开发前提是已经提供了一个接口文档还有一个前端的APK，开发工具就是Postman、goland这些。



#### 描述上一份实习

##### 为什么去这个公司，有什么能力和背景？

- 公司刚好当时有个项目在广州，公司派了人在广州，在天河智慧城那边

- 当时在校经历：在校做过量化策略，具体策略是行业轮动三个标尺的因子策略：动量、拥挤度、离散度。目前已经投入资金在跑，2022年最大回撤6.7%，年化在47%

- 对量化策略的具体解释：基于国信证券有关于行业轮动的三个标尺去做复现，基于聚宽260个因子的基础上对他们进行聚类（keams、层次聚类、dbscan等），对得出的结果进行barra风格归因，得出不同的风格做成策略，现在运行效果尚可

##### 实习做了什么事情

- 大部分时间都在写一些研报和做一些数据处理（比如用一些公式去计算二手房产估值
- 公司做了一个二手房资产信息网，可以查看相关二手房信息和生成一些分析报告；我参与过接入百度地图的api去展示相关经纬度的房产位置信息
- 微信支付流程优化有几方面
  - 使用spring cache 存储用户是否支付成功的信息
  - 设置合理的支付时间（5min
  - 设置合理的支付轮询，比如前端返回成功后才去支付轮询是否成功

#### 从上一份实习中你获得了什么？

- 从人际交往上：自己有个直属领导，也有一个属于指导我的员工，基本就是有什么活就会召集实习生或者mt一起开会，整理要做的任务习工作内容。相处下来我觉得对待自己的领导应该像对大哥大姐那样，工作上有什么困难实在解决不了就一定要跟领导说一下做什么事到什么进度什么方法下发现搞不定，也不能什么事情都问。对待和我一样的实习生就是像看弟弟妹妹那样，友好相处，相互帮助。
- 从技术上：公司的主要业务并不是和技术相关，所以做的比较杂，但是也算是接触到企业面对真正需求是如何进行开发的吧
- 研报部分：
  - 逻辑思路部分：重要的是形成结构化思维。先了解整体的发展与知识框架为第一步；数据完善部分，然后依托中央政策文件的时间路线为线路，辅以相关的研报数据，丰富这个框架树上的子叶知识数据；总结性部分：层层追问，对相关的问题根据链条层层发问。最后根据搭建的框架在团队的共同努力下去完善剩余信息的正确性和完整性
  - 还可以以结果导向型为目的去导引一些关键数据，有变化的地方肯定有原因

#### 如何看待压力？

我觉得从人的角度出发，我希望在工作中能够认真、负责人地做好自己的本职工作；在业余时间应该会有两部分，一部分是自己的兴趣爱好，另一部分是去进行技术能力的增长，比如工作中看到的问题还有一些自我学习方面上

### 项目经历方面

#### 瑞吉项目

##### 遇到的难点

- 流式编程
- 
- 主从复制配置

##### 服务器部署以及docker部署



##### RABC权限模型怎么理解？如何设计？

- RABC是一个基于角色的访问控制模型，将权限授权的管理任务从用户转移到角色上
  - 设计的话要从角色、权限、用户和角色的关系来设计
    - 定义角色
    - 定义权限，比如删除订单，新增订单，查看订单
    - 分配权限
    - 分配角色，哪些用户可以是什么角色
  - 一般来说数据库设计表的时候会多设计一张角色表、一个权限表（有权限url）、一个权限角色的中间表，用户表会多加一个字段来保存角色信息，通过这个字段能知道权限和角色
  - `@PreAuthorize`注解控制方法的访问权限，使用`@Secured`注解控制类的访问权限，使用`@PostAuthorize`注解对方法的返回结果进行权限校验等
  - 后端需要继承相关的类，开放不同的url给不同的角色，在登录的时候要从数据库查询相关的角色权限信息，这些信息可以放在jwt中
  - 前端也要写相关的识别权限信息的代码展示不同的界面

##### 如何给数据做预热？

首次方案页面时候将查询的数据放到redis中，第二次请求的时候先去请求缓存有没有，有的话直接从缓存拿，没有的话就从数据库拿并缓存

##### 说说流式编程的应用

比如需要返回一个嵌套的json格式数据，格式里边有个字段是其他表的部分字段，这个时候用流式编程将这个字段的信息用流式编程拷贝到相关的对象当中

##### 不存在的数据采用“缓存空值+布隆过滤器+接口基础校验“来解决

- 缓存空值：数据不存在的时候可以把这个特殊值缓存起来
- 布隆过滤器的话会提前去对发送的请求参数去判断这个参数之前有没有被存入到过滤器中，没有的话会到数据库中查询，有的话就去缓存中查询
- 基础校验的话通过写一个拦截器或者过滤器去实现，在获取请求的时候先对参数进行校验，比如是不是空值、长度、数据类型等等

##### 服务器部署方面

- redis.host的配置应改为127.0.0.1，当该jar包项目运行在服务器本地，才是以内网形式访问服务器本地的redis服务。即使这里的redis.host配置为服务器本身的外网ip，也仍然是以外网的形式访问服务器本地的redis服务，自然会被bind 127.0.0.1拒绝。按道理应该是只有本服务器能访问？
- 服务器部署流程：
  - 建议使用宝塔面板来进行管理，对于细节直接进入相关配置文件进行修改就好了
  - 数据库文件统一使用navicat进行转储到数据库去执行
  - **nohup** 命令可以让项目不挂断持续的在服务器后台去运行，具体的操作是去编写一个sh脚本（其中可以包括在github上面去拉取最新的代码去运行），要关闭他的话就杀死他
- docker容器部署项目流程
- 服务器docker容器部署项目流程

##### docker部署

- 先检查有什么镜像和版本
- 拉去相关软件的镜像，配置好映射的端口，别名
- 修改相关配置文件
- spingboot项目要打包成jar包并且编写一个dockerfile文件，dockerfile要和jar在同一个文件夹
- 构建镜像

##### security方面

![image-20230329001239924](C:\Users\XiaoXiang\AppData\Roaming\Typora\typora-user-images\image-20230329001239924.png)

##### 说说spring security

security是spring中的一个安全管理框架，他比shrio有更丰富的功能和社区，一般来说中大型的项目都是用security，小项目用的是shrio。后者更加轻量级。

使用的目的一般都是用来做认证和授权

##### 简要说明一下使用带JWT的登录验证校验

- 前端发送一个表单请求
- 后端收到后去数据库拿到用户名和密码进行校验
- 正确的话就会用用户名的id或者用户名去生成一个jwt
- 在登录之后访问请求都要带一个token
- 后端每每接受一个请求都需要对token进行解析，获取userid
- 根据用户id去查询相关信息，如果有权限就访问相关资源
- 最后将数据返回

##### 说一说整个spring security的整个开发流程

首先spring security的原理是一个过滤器链，核心过滤链主要就是做了一些登录校验和权限功能

**（在整个的核心过滤器链中，必须要重写的的应该是一个基于内存中去查找相关权限信息的接口；另一个是最后返回了某个确定的结果，要根据实际业务去进行重写，返回相应的数据）**

开发security主要有以下几个要点

​	首先肯定是有了登录校验才能够查询权限，因此先从登录校验起，**登录校验包括**

- **数据库校验用户名与密码是否正确。**Spring Security会调用实现了UserDetailsService接口的类来获取该用户的UserDetails信息，然后进行密码校验等操作。因此，如果要使用Spring Security进行登录校验，就需要实现UserDetailsService接口，并在该接口的实现类中返回UserDetails对象。

  - 根据实际业务，常常都是要重新定义一个类去实现UserDetails接口，把相关的实体加到重写的方法当中

- 密码的加密存储

- 具体的登录接口实现。

  - 放行登录注册页面
  - 成功后要根据id或者用户名生成jwt并且返回给用户，并且要把用户信息放入redis，可以把用户id作为key

- 添加认证过滤器。我们需要自定义一个过滤器，这个过滤器会去获取请求头中的token，对token进行解析取出其中的userid。使用userid去redis中获取对应的LoginUser对象。然后封装Authentication对象存入SecurityContextHolder

- 退出登录。我们只需要定义一个登陆接口，然后获取SecurityContextHolder中的认证信息，删除redis中对应的数据即可。

  

完成登录验证以后，后续每次请求都应该去携带token进行验证并且查询相关权限，**授权流程如下：**

- 开启访问资源所需权限@EnableGlobalMethodSecurity(prePostEnabled = true)
- 在数据库设计好相应的权限表（RBAC权限模型），然后从数据库去查询相关的权限信息，封装到UserDetails中返回（或者UserDetails的实现类当中）



##### 为什么前后端分离的项目用要用token

- 在前后端分离的项目中，后端不再掌握渲染页面和处理用户输入的功能，它只是提供接口服务。因此，前端和后端之间需要进行频繁的交互，每个请求都需要携带认证信息以确保请求的合法性和安全性。如果没有认证机制，客户端可以轻易地伪造请求，进行非法操作，这将导致系统数据被篡改或窃取，带来严重的安全风险。

- 因此，在前后端分离的项目中，一般采用Token认证机制来保证请求的合法性和安全性。Token是指一种身份验证令牌，它是一段加密的字符串，可以包含用户身份信息、过期时间等内容，用于验证客户端身份并限制客户端的操作权限。客户端每次请求时需要将Token携带在请求头或请求参数中，后端对Token进行验证后才能继续处理请求。Token机制相比于Session机制，更加灵活和安全，也更适合前后端分离的项目。

##### 多种认证方案畅想

在过滤器链最前面增加一条验证码的过滤器链,自定义一个即可

#### 抖音极简版

什么是哈希加盐

##### 你可以详细描述一下你使用Gin框架和Gorm ORM框架的经验和能力吗？

密码哈希加盐是指在对用户密码进行哈希运算（Hash）之前，先将一个随机的字符串（称为盐）添加到用户密码的末尾或者开头，再进行哈希运算。这样做的目的是增加密码的安全性，即使两个用户的密码相同，由于盐的不同，其哈希结果也会不同。在存储用户密码的数据库中，一般会同时存储盐和哈希结果，以便在验证用户密码时能够正确比对。这种方式可以有效地防止黑客使用彩虹表等常见攻击手段来破解用户密码。

##### 如何异步上传视频？

使用 Kafka 的订阅发布模型，可以将用户投稿上传视频的过程异步化，具体实现可以分为以下几个步骤：

1. 定义 Kafka Topic：定义一个 Kafka Topic，例如 `video_upload`，用于存储用户投稿上传视频的消息。
2. 生产者发布消息：在用户上传视频时，将视频文件以及其他相关信息打包成一条消息，发送到 Kafka Topic `video_upload` 中。这个过程可以通过 Kafka 生产者实现。
3. 消费者接收消息：启动一个 Kafka 消费者，订阅 Topic `video_upload`，并处理接收到的消息。消费者可以使用 Kafka 的 Consumer API 进行实现，可以使用 Spring Kafka 封装的 KafkaTemplate 等框架简化代码实现。
4. 异步上传视频：在消费者中，使用异步方式（例如多线程）将视频文件上传到云端存储（例如阿里云 OSS、腾讯云 COS 等）中，同时更新数据库中的相关记录（例如视频 URL、状态等）。在视频上传的过程中，可以利用 Kafka 的消息重试机制，保证消息不会丢失，同时可通过消息状态判断视频上传的状态，并进行相应的处理（例如上传失败后的重试、记录日志等）。
5. 可靠性保障：在生产者和消费者中都可以使用 Kafka 提供的一些可靠性保障机制，例如生产者的 ack 机制、消费者的 offset 管理等，以确保消息的可靠性和数据一致性。

### 其他

#### 了解过Sasa嘛？

Sasa区别于传统软件是以续费模式提供服务，会根据用户需求在续费周期内源源不断提供更新服务

#### Go和Java有什么区别？

相似之处：

1. 都是强类型语言，且支持面向对象编程和并发编程。
2. 都有垃圾回收机制，可以有效避免内存泄漏。
3. 都可以跨平台使用，具有良好的可移植性。
4. 都有丰富的第三方库和框架支持，可以方便地进行开发和部署。

不同之处：

1. Go 更加注重高并发和网络编程，具有轻量级线程（Goroutine）和基于消息的通信机制（Channel）等特性，而 Java 则更加适合大规模企业级应用开发。
2. Go 在语言层面支持多返回值，可以更加方便地处理一些场景，比如错误处理等，而 Java 则需要使用异常来进行处理。
3. Go 的编译速度很快，可以在几秒钟内完成编译，而 Java 的编译速度较慢，需要花费更多的时间。
4. Go 的语法更加简洁，代码行数较少，而 Java 的语法较为繁琐，代码行数较多。

总之，Go 和 Java 都是非常优秀的编程语言，各有其优点和适用场景。对于具体的项目需求，我们需要根据实际情况选择合适的编程语言和框架进行开发。

#### VO和DTO

VO（View Object）和DTO（Data Transfer Object）都是用于数据传输的Java对象，但它们在不同的层次和场景中使用。

VO一般用于表示展示层的数据模型，主要用于数据的展示和传递，它是面向用户的，包含了展示层的数据展示需要的所有属性，同时它也可以封装部分从业务实体层传递过来的属性。

DTO一般用于不同系统或不同层之间传输数据的对象，主要用于数据的传输，是一种数据载体，不包含任何业务逻辑，只提供了一个数据传输的对象，DTO 通常由 Service 层返回给 Controller 层或由远程调用返回给调用方，封装了需要传输的数据。

VO和DTO的区别在于它们的使用场景和用途。VO是用于封装前端的展示层数据的，主要用于展示，不涉及业务逻辑，通常是由Controller返回给前端。而DTO主要是用于系统之间或不同层之间数据传输，封装了需要传输的数据，是一个数据载体。在实际开发中，VO和DTO的使用可以根据实际情况灵活选择。

在Spring Boot项目中，为了避免在Controller中返回包含密码等敏感信息的User对象，可以创建一个DTO（Data Transfer Object）对象来代替User对象，并在DTO中仅包含需要返回的字段，而不包含敏感信息。DTO是一种用于数据传输的对象，它通常包含少量字段，用于在不同层之间传输数据。
